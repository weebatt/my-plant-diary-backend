# План реализации и журнал этапов

Документ описывает, что предстоит реализовать и что уже реализовано. После каждого этапа фиксируем подробный отчёт о недостатках и план исправлений. Цель — собрать надёжный базовый минимум без «выкрутасов», затем наращивать функциональность итеративно.

Сопутствующие документы:
- Архитектура: `ARCHITECTURE.md:1`
- Сообщения и топология RabbitMQ: `docs/messaging.md:1`

## Принципы
- Простота прежде всего: минимально достаточный функционал, явные границы сервисов.
- HTTP для синхронных вызовов; брокер (RabbitMQ) для асинхронных событий/команд.
- Данные на текущем этапе в монолите; асинхронные интеграции через события и outbox (при необходимости).
- Роли: `user`, `admin`. Доступ на запись в словарь — только `admin`.

## Этапы (M0…)

### M0 — Фундамент
Цель: сервисы стабильно поднимаются локально, общие конвенции по брокеру и БД, health‑checks, минимальные хелперы.
- Deliverables
  - Объявления RabbitMQ: `x.events`, `x.commands`, `x.dlx`; очереди `q.<service>.*` + DLQ.
  - Встроенная обёртка брокера в монолите: публикация/чтение `EventEnvelope` (JSON), headers, confirms/acks, prefetch.
  - Базовые Spring‑конфиги (AMQP, PostgreSQL), `/actuator/health` во всех сервисах.
  - Docker Compose: проверка доступности брокера и БД, переменные окружения.
- Критерии готовности
  - Все сервисы стартуют через Compose, health‑checks зелёные.
  - Топология создаётся на старте, сообщения проходят через тестовый publisher/consumer.
- Статус: Частично готово

### M1 — Пользователи и доступ
Цель: регистрация/аутентификация, роли, защищённые эндпоинты через `gateway`.
- Deliverables: модуль пользователей в монолите (модель пользователя, роль), простой auth (локальный JWT), охрана маршрутов.
- Критерии: авторизованный пользователь делает CRUD своих данных; роль `admin` присутствует в токене.
- Статус: Готово

Журнал: M1 — Пользователи и доступ
- Старт: текущий спринт → Завершён: текущий спринт
- Сделано:
  - Добавлены зависимости: Security, OAuth2 Resource Server, JPA, Liquibase, PostgreSQL драйвер, Springdoc OpenAPI.
  - Liquibase: создан changelog пользователей `apps/monolith/src/main/resources/db/changelog/001-users.yaml:1`.
  - Домен: сущность `User`, repo, сервис регистрации и проверки пароля (BCrypt).
  - Безопасность: базовая конфигурация, режимы — анонимный доступ (по умолчанию) и JWT Resource Server при `SECURITY_AUTH_ENABLED=true`.
  - Эндпоинты: `POST /auth/register` (всегда доступен), `POST /auth/login` (в режиме JWT), `GET /me` (JWT режим) — черновая реализация.
  - Конфиг: свойства `security.auth.jwt.*` и подключение к PostgreSQL (Liquibase применит миграции при старте).
- Риски/ограничения:
  - Требуется JDK 21 для локальной сборки через Gradle (или запуск через Docker Compose).
  - Токен HMAC JWT формируется локально в контроллере для простоты; в проде предполагается внешний Issuer или полноценный Authorization Server.
- Следующие шаги:
  - Добавить простейший CRUD профиля пользователя и защитить маршруты. — Сделано (`GET /profile`, `PATCH /profile`, `POST /profile/password` при включённом JWT)
  - Валидация пароля/почты и нормализованный формат ошибок (RFC 7807). — Базовая обработка реализована
  - Тесты (минимум интеграционные для регистрации/логина, M5) и seed админ‑пользователя. — Seed добавлен, тесты запланированы на M5

### M2 — Словарь растений (админский)
Цель: CRUD растений, поиск, рекомендации по параметрам (RDF4J минимально), импорт/seed.
- Deliverables: модуль словаря в монолите (PostgreSQL + при необходимости RDF4J), эндпоинт «рекомендации».
- Критерии: admin управляет словарём; рекомендации возвращаются по входным параметрам.
- Статус: Готово

Журнал: M2 — Словарь растений
- Старт: текущий спринт
- Сделано:
  - Миграция таблицы plants (002-plants)
  - Модель, репозиторий, сервис и админ‑контроллер для CRUD (JWT режим, админ‑роли)
  - Публичные эндпоинты: `GET /plants`, `GET /plants/{id}`, `GET /plants/recommendations`
  - Черновой алгоритм рекомендаций по фильтрам light/water и температурным границам
  - Пагинация/сортировка для публичного списка (`page`, `size`, `sort`, где `sort` поддерживает префикс `-` для DESC)
- Следующие шаги:
  - Завершить описание OpenAPI для словаря (после стабилизации моделей)
  - Добавить seed нескольких растений для локальной среды (при необходимости)

### M3 — Дневник пользователя
Цель: учёт «моих растений», записи ухода, напоминания, события в брокер.
- Deliverables: модуль дневника в монолите: CRUD, запрос рекомендаций к модулю словаря, outbox событий `diary.*.v1`.
- Критерии: пользователь ведёт дневник; события публикуются в `x.events`.
- Статус: Готово

Журнал: M3 — Дневник пользователя
- Старт: текущий спринт
- Сделано:
  - Миграции: user_plants, care_entries, reminders (003-diary)
  - Модели/репозитории: UserPlant, CareEntry, Reminder
  - Сервис дневника: CRUD, напоминания, публикация событий `diary.reminder.{created|completed}.v1`
  - Валидация видов ухода/напоминаний (enum и нормализация)
  - Эндпоинты (JWT‑режим):
    - Пользовательские растения: `GET/POST /diary/plants`, `PATCH/DELETE /diary/plants/{id}`
    - Записи ухода: `GET/POST /diary/care/{userPlantId}` (+ пагинация/сортировка в списке)
    - Напоминания: `GET /diary/reminders/due?before=...` (+ пагинация/сортировка), `POST /diary/reminders/{userPlantId}`, `POST /diary/reminders/complete/{reminderId}`
  - Контракты событий дневника добавлены в `contracts`
  - Коллекция Postman расширена (авторизация, словарь, дневник)
  - Seed растений для локалки (управляется `SEED_PLANTS_ENABLED`)
- Следующие шаги:
  - Базовая валидация входных данных и расширенное логирование — частично сделано
  - Публикация событий для записей ухода (при необходимости)
  - Интеграционные тесты (позже, M5)

### M4 — Календарь/Планировщик
Цель: синхронизация напоминаний → расписание, API календарных представлений.
- Deliverables: модуль планировщика в монолите: слоты по `diary.reminder.*`, API day/week/month.
- Критерии: изменения из дневника отражаются в календаре за секунды.
- Статус: Готово

Журнал: M4 — Календарь/Планировщик
 - Старт: текущий спринт → Завершён: текущий спринт
 - Сделано:
  - Сервис календаря строит представления day/week/month поверх таблицы reminders
  - Эндпоинты (JWT): `GET /calendar/day?date=YYYY-MM-DD`, `GET /calendar/week?start=YYYY-MM-DD`, `GET /calendar/month?year=YYYY&month=MM`
  - Пагинация/сортировка для календаря (`page,size,sort`)
  - Метаданные растения (ник, латинское и обычное название) в ответе
 - Следующие шаги:
  - Подписка на события и фоновая синхронизация — по мере необходимости

### M5 — Наблюдаемость и качество
Цель: метрики, трейсы, алерты на DLQ, интеграционные тесты.
- Deliverables: Micrometer/OTel, Testcontainers (RabbitMQ, PostgreSQL), алерты/дашборды (минимум).
- Критерии: стабильные сборки, контролируемый DLQ.
- Статус: Готово (минимальный объём)

Журнал: M5 — Наблюдаемость и качество
- Сделано:
  - Метрики Prometheus через Micrometer, эндпоинт `/actuator/prometheus`
  - Подготовлены зависимости Testcontainers для будущих интеграционных тестов
- Что улучшить (после MVP):
  - Добавить интеграционные тесты с Testcontainers для дневника и словаря
  - Настроить алерты/дашборды в Grafana/Prometheus

Отдельный поток после M4 (N‑серия): уведомления (Orchestrator, Telegram, WebPush), интеграция Avito.

## Журнал этапов

Шаблон отчёта по этапу (заполняется по завершении каждого Mx):
- Даты: старт → завершение
- Сделано:
  - Ключевые результаты (коротко)
  - Внесённые изменения (ссылки на модули/файлы)
- Недостатки/риски:
  - Технические (производительность, устойчивость, DX)
  - Продуктовые (пробелы UX, сценарии)
- Что исправить/улучшить:
  - Быстрые фиксы (следующий спринт)
  - Долгосрочные улучшения (бэклог)

### Журнал: M0 — Фундамент
- Статус: Частично готово
- Сделано:
  - Монолит: добавлены обёртки и конфигурация для RabbitMQ (publisher с confirms, consumer с ручными ack, prefetch), объявление топологии (обменники/очереди/DLX).
  - Dev‑эндпоинт `/dev/emit/reminder` публикует тестовое событие `notification.reminder.due.v1` в `x.events`.
  - Docker Compose: добавлены сервисы RabbitMQ (с UI) и PostgreSQL; монолит зависит от них, включена переменная `APP_MESSAGING_ENABLED=true`.
  - Обновлены настройки `application.yml` для подключения к RabbitMQ.
  - Обновлён `.env.example` (порты и переменные для RabbitMQ/Postgres).
- Недостатки/риски:
  - Локальная сборка требует JDK 21 (Gradle toolchain); в окружении с JDK 17 сборка не пройдёт без обновления JDK.
  - PostgreSQL пока не используется монолитом (подключение и миграции запланированы на M1/M2).
- Что исправить/улучшить:
  - Добавить интеграционные тесты с Testcontainers для RabbitMQ (M5).
  - Подключить БД и миграции Liquibase для доменных модулей (M1–M3).
  - Добавить реплей из DLQ/утилиты при необходимости.

## Текущие задачи (M0)
- Объявить exchanges/queues/bindings по `docs/messaging.md` в монолите. — Сделано
- Реализовать встроенные publisher/consumer helpers для `EventEnvelope` (JSON, headers, confirms, manual ack). — Сделано
- Настроить `prefetch`, ручные подтверждения, политику DLQ. — Сделано
- Добавить `/actuator/health` и базовые readiness/liveness во все сервисы. — Есть `/healthz` и Actuator health
- Проверить Compose: доступность RabbitMQ UI и БД, переменные окружения. — Сделано (RabbitMQ UI на `${RABBITMQ_MANAGEMENT_PORT:-15672}`)

## Правила обновления документа
- После завершения этапа: заполнить раздел журнала по шаблону (ниже списка этапов).
- При изменении планов: корректировать цели/критерии и статусы этапов, фиксировать причины.
- Поддерживать ссылки на релевантные файлы (миграции, конфиги, контракты).
